# 상태 관리에 대한 고민

### 1. 배경

- Stomp protocol 통신은 `StompClientLib` 라이브러리 사용 (https://github.com/WrathChaos/StompClientLib)
    - 위 라이브러리의 구현체로는 본 프로젝트에서 `ChatWebSocketService` 에서 구현
- 현재 `Smooth` 에서는 상태관리의 확인을 WebSocket 기반의 `Stomp` 프로토콜을 이용해서 구현
- 하지만, Chatting 기능도 `Stomp` 프로토콜을 이용하여 메시징 처리

### 2. **해결 해야하는 문제**

현재 Service layer는 ViewModel에서 protocol을 DI 받는 구조로 되어 있다.

→ 이럴 경우, 다른 화면으로 이동(또는 ViewModel 선언) 시 socket 상태를 공유 받지 못함

따라서, 상태 관리 기능을 구현하기 위해 `socket이 현재 화면 위치와 무관하게 공유 되어야 한다`.

### 3. **과정**

[상태 관리에 대한 정의]

- 유저의 상태는 앱 시작과 동시에 실행 되어야 한다.
- 각 화면 이동 시 그에 맞는 장소 및 결과를 서버에 전송 해줘야 한다.

[try 1] 

- (idea 1) 앱이 유효한 시작은, `AppDelegate`이니, 시작점에서부터 StompClinet 생성
- (idea 2) 소켓 통신이 필요한 `ViewModel`인 경우, `AppDelegate`에서 해당 클라이언트를 가져와 사용

```swift
class AppDelegate: UIResponder, UIApplicationDelegate {
    
    var coordinator: MainCoordinator?
    var window: UIWindow?
    var chatWebSocketService: ChatWebSocketServiceProtocol?
    
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        window = UIWindow(frame: UIScreen.main.bounds)
        chatWebSocketService = ChatWebSocketService()
        chatWebSocketService?.register()
        
        RxImagePickerDelegateProxy.register { RxImagePickerDelegateProxy(imagePicker: $0) }
        
        coordinator = MainCoordinator(window: window!)
        coordinator?.start()
        window?.makeKeyAndVisible()
        
        return true
		}
...
```

```swift
class ChattingViewModel: BaseViewModel {
let chattingService: ChattingServiceProtocol
let chatWebSocketService: ChatWebSocketService
... 
	init(
	        chattingService: ChattingServiceProtocol
	    ) {
	        self.chattingService = chattingService
	        let appDelegate = UIApplication.shared.delegate as? AppDelegate
	        self.chatWebSocketService = appDelegate?.chatWebSocketService as! ChatWebSocketService
	        
	        super.init()
	    }
...
}
```

[try 1] 결과

- [x]  App 시작 시 정상적으로 socket 연결 확인
- [x]  socket이 필요한 화면인 경우 `chatWebSocketService` 를 주입 받고, 정상 동작 확인

→ socket connect 시 user의 access token 필요! (UserDefault로 접근이 필요함)

[try 2]

- (idea 1) `AppDelegate` 에서 UserDefault를 사용하여 token 정보를 얻는다.
- (idea 2) token이 생성되는 시점에 맞춰 `connect`를 시도를 한다.

[try 2] 결과 

- idea 1 : 앱 실행 시 토큰이 없는 경우(새로 가입한 경우) 해당 유저는 socket 연결을 하지 못하는 이슈 발생
    - 따라서, token 저장 시점에 주목하여, socket regist 시도 하는 방향으로 전환 (idea2)
- idea 2
    - 토큰이 생성되는 시점은 `MainCoordinator`에서 그에 맞춰 적절한 화면을 제공해주고 있다.
        - Coordinator pattern의 장점을 살림
    
    - 따라서, `MainCoordinator` 를 기준으로 token 소유 여부에 따라, socekt regist

### 4. 결론

- 각 화면에 대한 소켓 의존성은, `MainCoordinator` 를 활용하여 의존성 주입
    - `MainCoordinator` : 유효한 사용자가 로그인한 상태 보장
        - socket 통신이 필요한 모든 화면은 MainCoordinator의 childCoordinator 임으로  `chatWebSocketService` 는 MainCoordinator가 시작되는 시점에서부터 인스턴스를 생성